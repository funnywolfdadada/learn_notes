char型变量向上转化会转化成int型
this(...)调用构造方法，但不能调用两个，并且对this的调用必须是构造器中的第一个语句
Java中：1、对象可能不被垃圾回收；2、垃圾回收不等于“析构”；3、垃圾回收只与内存有关
finalize()的作用是之前调用了native方法来分配内存，对象被垃圾回收时，需要在finalize方法中释放掉
Java初始化顺序：
	->父类静态代码块或变量（按定义顺序）
	->子类静态代码块或变量
	->父类成员变量或代码块->构造函数
	->子类成员变量或代码块->构造函数
String[] s = new String[10]; 只是创建了一个拥有10个String引用的数组s，它里面的内容都是null
Java访问权限从大到小依次是：public、protected（包内及子类可以访问）、包访问权限（没有关键字）和private
外部类的访问权限不能是protected或private，内部类可以
命令"java ClassName"就可以调用ClassName类的main方法，即使这个类不是public的
Java子类中重载基类中的方法并不会屏蔽基类中的任何版本
@Override注解可以防止在复写时意外地进行了重载
Java中除了static方法和final方法（private方法属于final方法）外，其他所有方法都支持后期绑定
	final方法禁止Override，static方法和数据成员（域，field）在编译时进行解析 (8.2.5, P157)
	构造方法中调用普通函数也可以多态，但是数据成员可能未完全初始化，构造器中唯一能安全调用
	的方法是基类的final方法 (8.3.3, P163)
包含抽象方法的类为抽象类，必须用abstract关键字修饰 (9.1, P169)
interface的域隐式地是static和final的，方法都是public的 (9.2, P172)
使用interface的原因：为了能够向上转型为多个基类型；防止创建该类对象 (9.4, P179)
interface可以extends多个其他的interface (9.5, P180)
内部类拥有其外部类所有元素的访问权 (10.2, P192)
内部类中用static，只能用在static final的常量变量上
要直接创建内部类对象，必须用外部类对象.new来创建 (10.3, P193)
匿名内部类访问的外部变量必须是final的，构造时传给基类的参数可以不是final的 (10.6, P198)
匿名内部类只能实现一个类或接口 (10.6, P199)
声明为static的内部类为嵌套类，他与普通内部类的区别：
	1、创建嵌套类对象不需要其外部类的对象
	2、嵌套类中不能访问非静态的外部类对象，也不能通过this访问外部类
	3、嵌套类可以有static数据和static字段，可以再包含嵌套类
接口中的内部类都是public和static的 (10.7, P202)
"java Outer\$Inner"可以用来执行内部类中的main方法，Inner必须是static的 (10.7, P203) 
为什么需要内部类：内部类可以操作创建它的外部类的对象，每个内部类都独立的继承一个实现，
	所以无论外部类是否已经继承某个实现，对内部类无影响
继承内部类时，子类的构造函数必须传入外部类引用，并用Outer.super()才能提供必要的引用 (10.9, P212)
局部内部类不属于外部类的一部分，不能有访问说明符，但可以访问代码块内部的常量及其外部类的成员
局部内部类和匿名内部类的区别：可以重载构造函数，可以定义多个 (10.11, P215)
非静态内部类或匿名内部类会持有一个外部类的隐式引用，可能导致内存泄漏






